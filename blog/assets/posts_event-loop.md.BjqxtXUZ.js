import{_ as o,c as a,o as e,a5 as l,bf as d,bg as i}from"./chunks/framework.DPO_DQk3.js";const m=JSON.parse('{"title":"深入浅出事件循环","description":"","frontmatter":{"title":"深入浅出事件循环","date":"2025-03-03T00:00:00.000Z"},"headers":[],"relativePath":"posts/event-loop.md","filePath":"posts/event-loop.md"}'),p={name:"posts/event-loop.md"};function r(s,t,c,n,u,h){return e(),a("div",null,t[0]||(t[0]=[l('<p>在当今互联网时代，网站性能优化已经成为前端开发中不可或缺的一部分。其中，浏览器缓存是提升网站性能最有效的方式之一。本文将深入浅出地讲解浏览器缓存机制，帮助你更好地理解和使用缓存策略。</p><hr><h2 id="出现事件循环的原因" tabindex="-1">出现事件循环的原因 <a class="header-anchor" href="#出现事件循环的原因" aria-label="Permalink to “出现事件循环的原因”">​</a></h2><p>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它<strong>只能是单线程</strong>，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><div class="tip custom-block"><p class="custom-block-title custom-block-title-default">TIP</p><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p></div><div class="info custom-block"><p class="custom-block-title">线程与进程</p><ul><li>进程（Process）：程序的一次执行实例，包含代码、数据、堆栈等资源，是操作系统进行资源分配的基本单位。一个进程可以包含多个线程。</li><li>线程（Thread）：进程中的一个执行流，共享进程的资源（如内存、文件句柄），是操作系统调度的最小单位。</li></ul><table tabindex="0"><thead><tr><th>特性</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>资源独立性</td><td>独立的内存空间、文件描述符等</td><td>共享进程的所有资源</td></tr><tr><td>调度单位</td><td>操作系统调度进程</td><td>操作系统调度线程（更细粒度）</td></tr><tr><td>通信成本</td><td>需通过 IPC（管道、消息队列等）</td><td>直接共享内存，通信更高效</td></tr><tr><td>创建开销</td><td>大（分配独立资源）</td><td>小（复用进程资源）</td></tr><tr><td>崩溃影响</td><td>只影响自身</td><td>整个进程崩溃</td></tr></tbody></table><ul><li><p>进程好比是多个独立房间（每个房间有独立设施）。</p></li><li><p>线程好比是同一房间内的多个工作人员（共享房间资源）。</p></li></ul><p>在 windows 中 使用 <code>shift + esc</code> 查看 浏览器中的进程 <img src="'+d+'" alt="进程与线程"></p></div><h2 id="同步任务和异步任务" tabindex="-1">同步任务和异步任务 <a class="header-anchor" href="#同步任务和异步任务" aria-label="Permalink to “同步任务和异步任务”">​</a></h2><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等待。</p><p>JavaScript开发人员意识到，为了不影响主线程正常运行，就把那些耗时的时间（比如定时器，Ajax操作从网络读取数据等）任务挂起来，依次的放进一个任务队列中，等主线程的任务执行完毕后，再回过来去继续执行队列中的任务；</p><p>于是，任务就可以分成两种：</p><ul><li>同步任务(synchronous)：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</li><li>异步任务(asynchronous)：不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><p>执行机制过程如下：</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（调用栈）</li><li>主线程之外，还存在一个‘任务队列’（task queue），浏览器中的各种 Web API 为异步的代码提供了一个单独的运行空间，当异步的代码运行完毕以后，会将代码中的回调送入到 任务队列中（队列遵循先进先出得原则）</li><li>一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。 其实，这一过程就是我们要了解的event loop（事件循环）机制； 下图就是主线程和任务队列的示意图。</li></ol><p><img src="'+i+'" alt="event loop"></p><p>主线程从&quot;任务队列&quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p><p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在&quot;任务队列&quot;中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取&quot;任务队列&quot;，依次执行那些事件所对应的回调函数。</p>',17)]))}const v=o(p,[["render",r]]);export{m as __pageData,v as default};
