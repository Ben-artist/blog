import{_ as s,c as t,o as a,a5 as o,bh as n,bi as i,bj as l,bk as e,bl as h,bm as p,bn as g}from"./chunks/framework.DPO_DQk3.js";const A=JSON.parse('{"title":"HTTPS解决了哪些HTTP的问题：SSL/TLS协议深度解析","description":"深入解析HTTP协议的安全问题，以及SSL/TLS协议如何通过加密、认证和完整性保护来解决这些问题。","frontmatter":{"title":"HTTPS解决了哪些HTTP的问题：SSL/TLS协议深度解析","date":"2025-07-15T00:00:00.000Z","tags":["网络协议","网络安全","HTTPS","SSL/TLS","加密传输"],"description":"深入解析HTTP协议的安全问题，以及SSL/TLS协议如何通过加密、认证和完整性保护来解决这些问题。"},"headers":[],"relativePath":"posts/http-to-https.md","filePath":"posts/http-to-https.md"}'),T={name:"posts/http-to-https.md"};function d(c,r,_,S,b,m){return a(),t("div",null,r[0]||(r[0]=[o('<p>在互联网发展的早期，HTTP协议以其简单高效的特点成为了Web通信的标准。然而，随着网络安全威胁的日益增加，HTTP协议的三大核心问题逐渐暴露：<strong>数据窃听</strong>、<strong>身份伪造</strong>和<strong>数据篡改</strong>。HTTPS通过引入SSL/TLS协议，完美地解决了这些问题。</p><hr><h2 id="为什么需要加密" tabindex="-1">为什么需要加密？ <a class="header-anchor" href="#为什么需要加密" aria-label="Permalink to “为什么需要加密？”">​</a></h2><p>因为HTTP的内容是<strong>明文传输</strong>的，明文数据会经过中间代理服务器、路由器、WiFi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是<strong>中间人攻击</strong>。所以我们才需要对信息进行加密。最容易理解的就是对称加密。</p><hr><h2 id="_1-对称加密" tabindex="-1">1. 对称加密 <a class="header-anchor" href="#_1-对称加密" aria-label="Permalink to “1. 对称加密”">​</a></h2><p><img src="'+n+'" alt="对称加密"></p><p>对称加密算法的<strong>加密和解密都是用同一个密钥</strong>。</p><p>如果通信双方都各自持有同一个密钥，且没有别人知道，则两方的通信安全是可以被保证的（除非密钥被破解）。</p><p>然而，<strong>最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道</strong>。如果由服务器生成一个密钥并传输给浏览器，这个传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容。</p><p>如果浏览器内部预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的。这样，浏览器只要预存好世界上所有HTTPS网站的密钥就可以了。显然，这样做是<strong>不现实的</strong>。</p><p>怎么办？解决这个问题，我们就需要<strong>非对称加密</strong>。</p><hr><h2 id="_2-非对称加密" tabindex="-1">2. 非对称加密 <a class="header-anchor" href="#_2-非对称加密" aria-label="Permalink to “2. 非对称加密”">​</a></h2><p><img src="'+i+'" alt="非对称加密"></p><p>基于对称加密存在的问题，又有了<strong>非对称加密</strong>。非对称加密算法需要一组<strong>密钥对</strong>，分别是<strong>公钥</strong>和<strong>私钥</strong>，这两个密钥是成对出现的。<strong>公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密</strong>。私钥由服务器自己保存，公钥发送给客户端。客户端拿到公钥后可以对请求进行加密后发送给服务端，这时候就算中间被截获，<strong>没有私钥也无法解密发送的内容</strong>，这样确保了客户端发送到服务端数据的安全。</p><hr><h2 id="_3-非对称加密改良方案" tabindex="-1">3. 非对称加密改良方案 <a class="header-anchor" href="#_3-非对称加密改良方案" aria-label="Permalink to “3. 非对称加密改良方案”">​</a></h2><p><img src="'+l+'" alt="非对称加密改良方案"></p><p>通过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，是不是就能保证双向传输都安全了？请看下面的过程：</p><ol><li>某网站服务器拥有用于非对称加密的公钥A1、私钥A2；</li><li>浏览器拥有用于非对称加密的公钥B1、私钥B2。</li><li>浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。</li><li>浏览器把公钥B1明文传输给服务器。</li><li>之后浏览器向服务器传输的所有东西都用公钥A1加密，服务器收到后用私钥A2解密。由于只有服务器拥有私钥A2进行解密，所以能保证这条数据的安全。</li><li>服务器向浏览器传输的所有东西都用公钥B1加密，浏览器收到后用私钥B2解密。同上也可以保证这条数据的安全。</li></ol><p>可见确实可行。抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？<strong>最主要的原因是非对称加密算法非常耗时</strong>，特别是加密解密一些较大数据的时候有些力不从心。而<strong>对称加密快很多</strong>。那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？</p><hr><h2 id="_4-非对称加密-对称加密" tabindex="-1">4. 非对称加密 + 对称加密 <a class="header-anchor" href="#_4-非对称加密-对称加密" aria-label="Permalink to “4. 非对称加密 + 对称加密”">​</a></h2><p><img src="'+e+'" alt="非对称加密+对称加密"></p><p>既然非对称加密耗时，我们考虑是否可以采用<strong>非对称加密+对称加密结合</strong>的方式，而且要<strong>尽量减少非对称加密的次数</strong>。</p><p><strong>非对称加密、解密各只需一次的方法：</strong></p><ol><li>某网站服务器拥有用于非对称加密的公钥A1、私钥A2。</li><li>浏览器向网站服务器请求，服务器把公钥A1明文给传输浏览器。</li><li>浏览器随机生成一个用于<strong>对称加密的密钥X</strong>，用公钥A1加密后传给服务器。</li><li>服务器拿到后用私钥A2解密得到密钥X。</li><li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可。</li></ol><p><strong>HTTPS基本就是采用了这种方案。但还是有漏洞的。</strong></p><hr><h2 id="_5-中间人攻击" tabindex="-1">5. 中间人攻击 <a class="header-anchor" href="#_5-中间人攻击" aria-label="Permalink to “5. 中间人攻击”">​</a></h2><p><img src="'+h+'" alt="中间人攻击"></p><p>中间人的确无法得到浏览器生成的对称密钥X，这个密钥本身被公钥A1加密，只有服务器才能用私钥A2进行解密。然而中间人却完全不需要拿到私钥A2就能劫持信息，请看：</p><ol><li>某网站服务器拥有用于非对称加密的公钥A1、私钥A2。</li><li>浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。</li><li>中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）。</li><li>浏览器随机生成一个用于对称加密的密钥X，用公钥B1（浏览器不知道公钥被替换了）加密后传给服务器。</li><li>中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器。</li><li>服务器拿到后用私钥A2解密得到密钥X。</li></ol><p>这样在双方都不会发现异常的情况下，<strong>中间人得到了对称密钥X</strong>。<strong>根本原因是浏览器无法确认自己收到的公钥是不是网站自己的</strong>。那么下一步就是解决这个问题：<strong>如何证明浏览器收到的公钥一定是该网站的公钥？</strong></p><hr><h2 id="_6-数字证书" tabindex="-1">6. 数字证书 <a class="header-anchor" href="#_6-数字证书" aria-label="Permalink to “6. 数字证书”">​</a></h2><p>现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了 <strong>&quot;公信&quot;</strong> 的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中也有这么一个公信机构，<strong>CA机构</strong>。</p><p>网站在使用HTTPS前，需要向 <strong>&quot;CA机构&quot;</strong> 申请颁发一数字证书，数字证书里有证书持有者、证书持有者的公钥等信息。服务器把证书传输给浏览器，浏览器从证书里取公钥就可以了。然而这里又有一个显而易见的问题：<strong>证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？</strong></p><hr><h2 id="_7-数字签名" tabindex="-1">7. 数字签名 <a class="header-anchor" href="#_7-数字签名" aria-label="Permalink to “7. 数字签名”">​</a></h2><p><img src="'+p+'" alt="数字签名"></p><h3 id="数字签名的制作过程" tabindex="-1">数字签名的制作过程： <a class="header-anchor" href="#数字签名的制作过程" aria-label="Permalink to “数字签名的制作过程：”">​</a></h3><ol><li>CA拥有非对称加密的私钥和公钥。</li><li>CA对证书明文信息进行hash。</li><li>对hash后的值用私钥加密，得到数字签名。</li></ol><p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。</p><h3 id="浏览器验证过程" tabindex="-1">浏览器验证过程： <a class="header-anchor" href="#浏览器验证过程" aria-label="Permalink to “浏览器验证过程：”">​</a></h3><ol><li>拿到证书，得到明文T1，数字签名S1。</li><li>用CA机构的公钥对S1解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S2。</li><li>用证书里说明的hash算法对明文T1进行hash得到T2。</li><li>比较S2是否等于T2，等于则表明证书可信。</li></ol><h3 id="为什么这样可以证明证书可信" tabindex="-1">为什么这样可以证明证书可信？ <a class="header-anchor" href="#为什么这样可以证明证书可信" aria-label="Permalink to “为什么这样可以证明证书可信？”">​</a></h3><p>假设中间人篡改了证书的原文，由于他没有<strong>CA机构的私钥</strong>，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现<strong>原文和签名解密后的值不一致</strong>，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p><h3 id="既然不可能篡改-那如果整个证书被掉包呢" tabindex="-1">既然不可能篡改，那如果整个证书被掉包呢？ <a class="header-anchor" href="#既然不可能篡改-那如果整个证书被掉包呢" aria-label="Permalink to “既然不可能篡改，那如果整个证书被掉包呢？”">​</a></h3><p>假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。</p><p>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p><h3 id="制作数字签名时为什么需要hash一次" tabindex="-1">制作数字签名时为什么需要hash一次？ <a class="header-anchor" href="#制作数字签名时为什么需要hash一次" aria-label="Permalink to “制作数字签名时为什么需要hash一次？”">​</a></h3><p>最显然的是<strong>性能问题</strong>，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而<strong>hash后得到的是固定长度的信息</strong>（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。当然除此之外也有安全上的原因。</p><h3 id="https必须在每次请求中都要先在ssl-tls层进行握手传输密钥吗" tabindex="-1">HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？ <a class="header-anchor" href="#https必须在每次请求中都要先在ssl-tls层进行握手传输密钥吗" aria-label="Permalink to “HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？”">​</a></h3><p>显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？<strong>用session就可以</strong>。</p><p>服务器会为每个浏览器（或客户端软件）维护一个<strong>session ID</strong>，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了。</p><hr><h2 id="_8-https-工作原理" tabindex="-1">8. HTTPS 工作原理 <a class="header-anchor" href="#_8-https-工作原理" aria-label="Permalink to “8. HTTPS 工作原理”">​</a></h2><p><img src="'+g+'" alt="HTTPS工作原理"></p><h3 id="详细步骤" tabindex="-1">详细步骤： <a class="header-anchor" href="#详细步骤" aria-label="Permalink to “详细步骤：”">​</a></h3><ol><li><p><strong>客户端发起请求</strong>：client向server发送请求<a href="https://baidu.com" target="_blank" rel="noreferrer">https://baidu.com</a>，然后连接到server的443端口。</p></li><li><p><strong>服务端准备证书</strong>：服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。</p></li><li><p><strong>传送证书</strong>：这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。</p></li><li><p><strong>客户端解析证书</strong>：这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。</p></li><li><p><strong>传送加密信息</strong>：这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p></li><li><p><strong>服务端解密信息</strong>：服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。</p></li><li><p><strong>传输加密后的信息</strong>：这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。</p></li><li><p><strong>客户端解密信息</strong>：客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。</p></li></ol><hr><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><p>通过以上步骤，我们可以看到HTTPS是如何通过<strong>对称加密</strong>、<strong>非对称加密</strong>、<strong>数字证书</strong>和<strong>数字签名</strong>等技术，解决了HTTP协议的安全问题：</p><ol><li><strong>对称加密</strong>：提供高效的加密解密</li><li><strong>非对称加密</strong>：解决密钥分发问题</li><li><strong>数字证书</strong>：验证服务器身份</li><li><strong>数字签名</strong>：确保证书不被篡改</li><li><strong>Session机制</strong>：提高性能，避免重复握手</li></ol><p><strong>HTTPS不仅保护了数据传输的安全性，还确保了通信双方的身份认证，是现代互联网安全的基础。</strong></p>',67)]))}const f=s(T,[["render",d]]);export{A as __pageData,f as default};
